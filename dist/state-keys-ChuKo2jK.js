import{E as e,f as t,i as n,n as r,r as i,v as a}from"./logger-A9pt5B3e.js";import o from"node:process";import*as s from"node:path";import*as c from"node:fs/promises";var l=e(t(),1);const u={restoreCache:async(e,t,n)=>l.restoreCache(e,t,n),saveCache:async(e,t)=>l.saveCache(e,t)};async function d(e){let{components:t,logger:n,storagePath:a,authPath:s,cacheAdapter:l=u}=e;if(o.env.SKIP_CACHE===`true`)return n.debug(`Skipping cache restore (SKIP_CACHE=true)`),await c.mkdir(a,{recursive:!0}),{hit:!1,key:null,restoredPath:null,corrupted:!1};let d=r(t),f=i(t);n.info(`Restoring cache`,{primaryKey:d,restoreKeys:[...f]});try{let e=await l.restoreCache([a],d,[...f]);return e==null?(n.info(`Cache miss - starting with fresh state`),await c.mkdir(a,{recursive:!0}),{hit:!1,key:null,restoredPath:null,corrupted:!1}):(n.info(`Cache restored`,{restoredKey:e}),await h(a,n)===!0?(n.warning(`Cache corruption detected - proceeding with clean state`),await v(a),{hit:!0,key:e,restoredPath:a,corrupted:!0}):await g(a,n)===!1?(n.warning(`Storage version mismatch - proceeding with clean state`),await v(a),{hit:!0,key:e,restoredPath:a,corrupted:!0}):(await m(s,a,n),{hit:!0,key:e,restoredPath:a,corrupted:!1}))}catch(e){return n.warning(`Cache restore failed`,{error:e instanceof Error?e.message:String(e)}),{hit:!1,key:null,restoredPath:null,corrupted:!1}}}async function f(e){let{components:t,runId:r,logger:i,storagePath:a,authPath:s,cacheAdapter:c=u}=e;if(o.env.SKIP_CACHE===`true`)return i.debug(`Skipping cache save (SKIP_CACHE=true)`),!0;let l=n(t,r);i.info(`Saving cache`,{saveKey:l});try{return await m(s,a,i),await y(a)===!1?(i.info(`No storage content to cache`),!1):(await _(a),await c.saveCache([a],l),i.info(`Cache saved`,{saveKey:l}),!0)}catch(e){return e instanceof Error&&e.message.includes(`already exists`)?(i.info(`Cache key already exists, skipping save`),!0):(i.warning(`Cache save failed`,{error:e instanceof Error?e.message:String(e)}),!1)}}function p(e,t){let n=s.resolve(e),r=s.resolve(t);return n.startsWith(r+s.sep)}async function m(e,t,n){if(!p(e,t)){n.debug(`auth.json is outside storage path - skipping deletion`,{authPath:e,storagePath:t});return}try{await c.unlink(e),n.debug(`Deleted auth.json from cache storage`)}catch(e){e.code!==`ENOENT`&&n.warning(`Failed to delete auth.json`,{error:e instanceof Error?e.message:String(e)})}}async function h(e,t){try{return(await c.stat(e)).isDirectory()===!1?!0:(await c.readdir(e),!1)}catch{return t.debug(`Storage path not accessible - treating as corrupted`),!0}}async function g(e,t){let n=s.join(e,`.version`);try{let e=await c.readFile(n,`utf8`),r=Number.parseInt(e.trim(),10);return r===a?!0:(t.info(`Storage version mismatch`,{expected:a,found:r}),!1)}catch{return t.debug(`No version file found - treating as compatible`),!0}}async function _(e){let t=s.join(e,`.version`);await c.mkdir(e,{recursive:!0}),await c.writeFile(t,String(a),`utf8`)}async function v(e){try{await c.rm(e,{recursive:!0,force:!0}),await c.mkdir(e,{recursive:!0})}catch{}}async function y(e){try{return(await c.readdir(e)).length>0}catch{return!1}}const b={SHOULD_SAVE_CACHE:`shouldSaveCache`,SESSION_ID:`sessionId`,CACHE_SAVED:`cacheSaved`};export{f as i,u as n,d as r,b as t};