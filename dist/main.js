import{C as e,a as t,c as n,d as r,f as i,i as a,l as o,m as s,n as c,o as l,p as u,r as d,t as f,u as p,y as m}from"./env-cNyaqPz_.js";import*as h from"node:fs/promises";import*as g from"node:path";import _ from"node:process";import{err as v,ok as y}from"@bfra.me/es/result";var b=e(m()),x=e(s());const S={restoreCache:async(e,t,n)=>x.restoreCache(e,t,n),saveCache:async(e,t)=>x.saveCache(e,t)};async function C(e){let{components:t,logger:n,storagePath:r,authPath:i,cacheAdapter:a=S}=e;if(_.env.SKIP_CACHE===`true`)return n.debug(`Skipping cache restore (SKIP_CACHE=true)`),await h.mkdir(r,{recursive:!0}),{hit:!1,key:null,restoredPath:null,corrupted:!1};let s=o(t),c=p(t);n.info(`Restoring cache`,{primaryKey:s,restoreKeys:[...c]});try{let e=await a.restoreCache([r],s,[...c]);return e==null?(n.info(`Cache miss - starting with fresh state`),await h.mkdir(r,{recursive:!0}),{hit:!1,key:null,restoredPath:null,corrupted:!1}):(n.info(`Cache restored`,{restoredKey:e}),await D(r,n)===!0?(n.warning(`Cache corruption detected - proceeding with clean state`),await A(r),{hit:!0,key:e,restoredPath:r,corrupted:!0}):await O(r,n)===!1?(n.warning(`Storage version mismatch - proceeding with clean state`),await A(r),{hit:!0,key:e,restoredPath:r,corrupted:!0}):(await E(i,r,n),{hit:!0,key:e,restoredPath:r,corrupted:!1}))}catch(e){return n.warning(`Cache restore failed`,{error:e instanceof Error?e.message:String(e)}),{hit:!1,key:null,restoredPath:null,corrupted:!1}}}async function w(e){let{components:t,runId:n,logger:i,storagePath:a,authPath:o,cacheAdapter:s=S}=e;if(_.env.SKIP_CACHE===`true`)return i.debug(`Skipping cache save (SKIP_CACHE=true)`),!0;let c=r(t,n);i.info(`Saving cache`,{saveKey:c});try{return await E(o,a,i),await j(a)===!1?(i.info(`No storage content to cache`),!1):(await k(a),await s.saveCache([a],c),i.info(`Cache saved`,{saveKey:c}),!0)}catch(e){return e instanceof Error&&e.message.includes(`already exists`)?(i.info(`Cache key already exists, skipping save`),!0):(i.warning(`Cache save failed`,{error:e instanceof Error?e.message:String(e)}),!1)}}function T(e,t){let n=g.resolve(e),r=g.resolve(t);return n.startsWith(r+g.sep)}async function E(e,t,n){if(!T(e,t)){n.debug(`auth.json is outside storage path - skipping deletion`,{authPath:e,storagePath:t});return}try{await h.unlink(e),n.debug(`Deleted auth.json from cache storage`)}catch(e){e.code!==`ENOENT`&&n.warning(`Failed to delete auth.json`,{error:e instanceof Error?e.message:String(e)})}}async function D(e,t){try{return(await h.stat(e)).isDirectory()===!1?!0:(await h.readdir(e),!1)}catch{return t.debug(`Storage path not accessible - treating as corrupted`),!0}}async function O(e,t){let n=g.join(e,`.version`);try{let e=await h.readFile(n,`utf8`),r=Number.parseInt(e.trim(),10);return r===u?!0:(t.info(`Storage version mismatch`,{expected:u,found:r}),!1)}catch{return t.debug(`No version file found - treating as compatible`),!0}}async function k(e){let t=g.join(e,`.version`);await h.mkdir(e,{recursive:!0}),await h.writeFile(t,String(u),`utf8`)}async function A(e){try{await h.rm(e,{recursive:!0,force:!0}),await h.mkdir(e,{recursive:!0})}catch{}}async function j(e){try{return(await h.readdir(e)).length>0}catch{return!1}}function M(e,t){try{JSON.parse(e)}catch{throw Error(`${t} must be valid JSON`)}}function N(e,t){let n=e.trim();if(!/^\d+$/.test(n))throw Error(`${t} must be a positive integer, received: ${e}`);let r=Number.parseInt(n,10);if(r===0)throw Error(`${t} must be a positive integer, received: ${e}`);return r}function P(){try{let e=b.getInput(`github-token`,{required:!0}).trim();if(e.length===0)return v(Error(`github-token is required but was not provided`));let t=b.getInput(`auth-json`,{required:!0}).trim();if(t.length===0)return v(Error(`auth-json is required but was not provided`));M(t,`auth-json`);let n=b.getInput(`prompt`).trim(),r=n.length>0?n:null,a=b.getInput(`session-retention`).trim(),o=a.length>0?N(a,`session-retention`):i,s=b.getInput(`s3-backup`).trim().toLowerCase()===`true`,c=b.getInput(`s3-bucket`).trim(),l=c.length>0?c:null,u=b.getInput(`aws-region`).trim();return y({githubToken:e,authJson:t,prompt:r,sessionRetention:o,s3Backup:s,s3Bucket:l,awsRegion:u.length>0?u:null})}catch(e){return v(e instanceof Error?e:Error(String(e)))}}function F(e){b.setOutput(`session-id`,e.sessionId??``),b.setOutput(`cache-status`,e.cacheStatus),b.setOutput(`duration`,e.duration)}async function I(){let e=Date.now(),r=n({phase:`bootstrap`});try{r.info(`Starting Fro Bot Agent`);let i=P();if(!i.success){b.setFailed(`Invalid inputs: ${i.error.message}`);return}let o=i.data,s=n({phase:`main`});s.info(`Action inputs parsed successfully`,{sessionRetention:o.sessionRetention,s3Backup:o.s3Backup,hasGithubToken:o.githubToken.length>0,hasPrompt:o.prompt!=null});let u=await C({components:{agentIdentity:`github`,repo:c(),ref:f(),os:l()},logger:n({phase:`cache`}),storagePath:t(),authPath:a()});s.info(`Cache restore completed`,{hit:u.hit,corrupted:u.corrupted,key:u.key}),s.info(`Agent infrastructure initialized`);let d=Date.now()-e;F({sessionId:null,cacheStatus:u.corrupted?`corrupted`:u.hit?`hit`:`miss`,duration:d}),s.info(`Agent run completed`,{durationMs:d})}catch(t){F({sessionId:null,cacheStatus:`miss`,duration:Date.now()-e}),t instanceof Error?(r.error(`Agent failed`,{error:t.message}),b.setFailed(t.message)):(r.error(`Agent failed with unknown error`),b.setFailed(`An unknown error occurred`))}finally{try{let e={agentIdentity:`github`,repo:c(),ref:f(),os:l()},r=n({phase:`cache-save`});await w({components:e,runId:d(),logger:r,storagePath:t(),authPath:a()})}catch{}}}await I();export{};