import{C as e,a as t,b as n,c as r,d as i,f as a,i as o,l as s,m as c,n as l,o as u,p as d,r as f,t as p,u as m}from"./env-CILO7IMS.js";import*as h from"node:fs/promises";import*as g from"node:path";import _ from"node:process";import{err as v,ok as y}from"@bfra.me/es/result";var b=e(n()),x=e(c());const S={restoreCache:async(e,t,n)=>x.restoreCache(e,t,n),saveCache:async(e,t)=>x.saveCache(e,t)};async function C(e){let{components:t,logger:n,storagePath:r,authPath:i,cacheAdapter:a=S}=e;if(_.env.SKIP_CACHE===`true`)return n.debug(`Skipping cache restore (SKIP_CACHE=true)`),await h.mkdir(r,{recursive:!0}),{hit:!1,key:null,restoredPath:null,corrupted:!1};let o=s(t),c=m(t);n.info(`Restoring cache`,{primaryKey:o,restoreKeys:[...c]});try{let e=await a.restoreCache([r],o,[...c]);return e==null?(n.info(`Cache miss - starting with fresh state`),await h.mkdir(r,{recursive:!0}),{hit:!1,key:null,restoredPath:null,corrupted:!1}):(n.info(`Cache restored`,{restoredKey:e}),await D(r,n)===!0?(n.warning(`Cache corruption detected - proceeding with clean state`),await A(r),{hit:!0,key:e,restoredPath:r,corrupted:!0}):await O(r,n)===!1?(n.warning(`Storage version mismatch - proceeding with clean state`),await A(r),{hit:!0,key:e,restoredPath:r,corrupted:!0}):(await E(i,r,n),{hit:!0,key:e,restoredPath:r,corrupted:!1}))}catch(e){return n.warning(`Cache restore failed`,{error:e instanceof Error?e.message:String(e)}),{hit:!1,key:null,restoredPath:null,corrupted:!1}}}async function w(e){let{components:t,runId:n,logger:r,storagePath:a,authPath:o,cacheAdapter:s=S}=e;if(_.env.SKIP_CACHE===`true`)return r.debug(`Skipping cache save (SKIP_CACHE=true)`),!0;let c=i(t,n);r.info(`Saving cache`,{saveKey:c});try{return await E(o,a,r),await j(a)===!1?(r.info(`No storage content to cache`),!1):(await k(a),await s.saveCache([a],c),r.info(`Cache saved`,{saveKey:c}),!0)}catch(e){return e instanceof Error&&e.message.includes(`already exists`)?(r.info(`Cache key already exists, skipping save`),!0):(r.warning(`Cache save failed`,{error:e instanceof Error?e.message:String(e)}),!1)}}function T(e,t){let n=g.resolve(e),r=g.resolve(t);return n.startsWith(r+g.sep)}async function E(e,t,n){if(!T(e,t)){n.debug(`auth.json is outside storage path - skipping deletion`,{authPath:e,storagePath:t});return}try{await h.unlink(e),n.debug(`Deleted auth.json from cache storage`)}catch(e){e.code!==`ENOENT`&&n.warning(`Failed to delete auth.json`,{error:e instanceof Error?e.message:String(e)})}}async function D(e,t){try{return(await h.stat(e)).isDirectory()===!1?!0:(await h.readdir(e),!1)}catch{return t.debug(`Storage path not accessible - treating as corrupted`),!0}}async function O(e,t){let n=g.join(e,`.version`);try{let e=await h.readFile(n,`utf8`),r=Number.parseInt(e.trim(),10);return r===d?!0:(t.info(`Storage version mismatch`,{expected:d,found:r}),!1)}catch{return t.debug(`No version file found - treating as compatible`),!0}}async function k(e){let t=g.join(e,`.version`);await h.mkdir(e,{recursive:!0}),await h.writeFile(t,String(d),`utf8`)}async function A(e){try{await h.rm(e,{recursive:!0,force:!0}),await h.mkdir(e,{recursive:!0})}catch{}}async function j(e){try{return(await h.readdir(e)).length>0}catch{return!1}}function M(e,t){try{JSON.parse(e)}catch{throw Error(`${t} must be valid JSON`)}}function N(e,t){let n=e.trim();if(!/^\d+$/.test(n))throw Error(`${t} must be a positive integer, received: ${e}`);let r=Number.parseInt(n,10);if(r===0)throw Error(`${t} must be a positive integer, received: ${e}`);return r}function P(){try{let e=b.getInput(`github-token`,{required:!0}).trim();if(e.length===0)return v(Error(`github-token is required but was not provided`));let t=b.getInput(`auth-json`,{required:!0}).trim();if(t.length===0)return v(Error(`auth-json is required but was not provided`));M(t,`auth-json`);let n=b.getInput(`prompt`).trim(),r=n.length>0?n:null,i=b.getInput(`session-retention`).trim(),o=i.length>0?N(i,`session-retention`):a,s=b.getInput(`s3-backup`).trim().toLowerCase()===`true`,c=b.getInput(`s3-bucket`).trim(),l=c.length>0?c:null,u=b.getInput(`aws-region`).trim();return y({githubToken:e,authJson:t,prompt:r,sessionRetention:o,s3Backup:s,s3Bucket:l,awsRegion:u.length>0?u:null})}catch(e){return v(e instanceof Error?e:Error(String(e)))}}function F(e){b.setOutput(`session-id`,e.sessionId??``),b.setOutput(`cache-status`,e.cacheStatus),b.setOutput(`duration`,e.duration)}async function I(){let e=Date.now(),n=r({phase:`bootstrap`});try{n.info(`Starting Fro Bot Agent`);let i=P();if(!i.success){b.setFailed(`Invalid inputs: ${i.error.message}`);return}let a=i.data,s=r({phase:`main`});s.info(`Action inputs parsed successfully`,{sessionRetention:a.sessionRetention,s3Backup:a.s3Backup,hasGithubToken:a.githubToken.length>0,hasPrompt:a.prompt!=null});let c=await C({components:{agentIdentity:`github`,repo:l(),ref:p(),os:u()},logger:r({phase:`cache`}),storagePath:t(),authPath:o()});s.info(`Cache restore completed`,{hit:c.hit,corrupted:c.corrupted,key:c.key}),s.info(`Agent infrastructure initialized`);let d=Date.now()-e;F({sessionId:null,cacheStatus:c.corrupted?`corrupted`:c.hit?`hit`:`miss`,duration:d}),s.info(`Agent run completed`,{durationMs:d})}catch(t){F({sessionId:null,cacheStatus:`miss`,duration:Date.now()-e}),t instanceof Error?(n.error(`Agent failed`,{error:t.message}),b.setFailed(t.message)):(n.error(`Agent failed with unknown error`),b.setFailed(`An unknown error occurred`))}finally{try{let e={agentIdentity:`github`,repo:l(),ref:p(),os:u()},n=r({phase:`cache-save`});await w({components:e,runId:f(),logger:n,storagePath:t(),authPath:o()})}catch{}}}await I();export{};